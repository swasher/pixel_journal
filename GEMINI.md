### Проект: "Pixel Journal"

#### **Цель проекта:**
Создание персонального web-приложения для ведения списка пройденных, запланированных и заброшенных игр. Это **serverless** проект, предназначенный для одного пользователя.

#### **Технологический стек:**
-   **Backend:** Firebase (Firestore, Authentication), Cloudinary, Netlify Functions (для безопасных запросов).
-   **Hosting:** Netlify.
-   **Frontend:** HTML, CSS, Svelte, Flowbite Svelte.
-   **API:** RAWG.io для поиска информации об играх.

---

### **Безопасное хранение API-ключей**

Для того чтобы API-ключ RAWG.io не попал в открытый доступ на фронтенде, мы будем использовать **Netlify Functions**. Это критически важный аспект безопасности проекта.

1.  **Принцип работы:** Netlify Functions — это небольшие, бессерверные функции, которые выполняются на сервере Netlify. Они имеют доступ к **переменным окружения (environment variables)**, которые безопасно хранятся в настройках проекта на Netlify.

2.  **Новый алгоритм:**
    * Фронтенд-код отправляет запрос **не напрямую** к RAWG.io, а к нашей Netlify Function, например `/api/search-game`.
    * Функция, получив запрос, извлекает API-ключ из своего безопасного окружения.
    * Функция делает запрос к RAWG.io API и возвращает полученные данные фронтенду.

3.  **Вывод:** Таким образом, ключ **никогда не попадает в браузер**, а все запросы к стороннему API проходят через безопасный серверный слой.

---


### **Основной план (Приоритет: 1)**

1.  **Страницы:** Создать 4 страницы, каждая из которых является списком игр:
    -   `Backlog` (надо пройти)
    -   `Completed` (пройдено)
    -   `Rejected` (не подошло)
    -   `Abandoned` (брошено)

2.  **Добавление игр:**
    -   Кнопка `ADD` на каждой странице.
    -   По нажатию появляется форма для поиска игры по названию.
    -   Игра добавляется в текущий список после поиска через **RAWG.io API**.

3.  **Отображение игр:**
    -   Каждая игра отображается в виде интерактивной карточки.
    -   На карточке должны быть поля: название, обложка, год выпуска.

4.  **Пользовательские данные:**
    -   После добавления игры, пользователь может внести свою информацию, которая сохраняется в **Firebase**:
        -   Текстовая заметка.
        -   "Сердце" (отметка **My favorite game**).
        -   Рейтинг (от 1 до 5 звезд).

5.  **Перенос игр:**
    -   Функционал для переноса игры из одной категории в другую путем обновления поля `status` в документе Firestore.

---

### **Структура данных в Firebase Firestore**

Данные хранятся в одной коллекции `games`. Каждый документ представляет собой одну игру.

-   **Коллекция:** `games`

-   **Поля документа:**
    -   `status` (string): Текущий статус игры (`backlog`, `completed`, `rejected`, `abandoned`).
    -   `title` (string): Название игры.
    -   `developer` (array): Массив строк с именами студий-разработчиков.
    -   `publisher` (string): Издатель.
    -   `year` (number): Год выпуска.
    -   `genres` (array): Массив жанров.
    -   `series` (string, optional): Серия, к которой относится игра.
    -   `image_url` (string): Ссылка на обложку с Cloudinary.
    -   `user_note` (string): Заметка пользователя.
    -   `is_favorite` (boolean): `true`, если игра отмечена как любимая.
    -   `user_rating` (number): Рейтинг от 1 до 5.
    -   `play_time` (number, optional): Время, потраченное на прохождение.
    -   `markdown_content` (string, optional): Содержимое для Markdown-заметок (для будущего).

---

### **Планы на будущее и дополнительные идеи**

Эти пункты не являются частью основной задачи и могут быть реализованы позже.

-   **Markdown-заметки:** Возможность создания подробных заметок с использованием Markdown-редактора.
-   **Поиск:** Полнотекстовый поиск по играм (по названию, жанру, разработчику).
-   **Теги:** Добавление пользовательских тегов (например, "хочу перепройти").
-   **Нестандартные блоки:** Возможность создавать текстовые блоки, не привязанные к конкретной игре.

---

### **Соглашения и особенности библиотек**

Во избежание ошибок и для обеспечения единообразия кода, здесь задокументированы особенности используемых библиотек.

1.  **Flowbite Svelte (`flowbite-svelte`)**
    *   **Обработка событий клика на компоненте `Button`**: Вместо стандартной для Svelte директивы `on:click` необходимо использовать `prop` (свойство) `onclick`.

        *   **Правильно:**
            ```svelte
            <script>
              import { Button } from 'flowbite-svelte';
              function handleClick() {
                console.log('Button clicked!');
              }
            </script>

            <Button onclick={handleClick}>Нажми меня</Button>
            ```

        *   **Неправильно:**
            ```svelte
            <!-- Этот код не будет работать -->
            <Button on:click={handleClick}>Нажми меня</Button>
            ```

2.  **Svelte 5 (Runes Mode)**
    *   В проекте используется Svelte 5 в режиме "runes mode". Все реактивное состояние должно объявляться с помощью рун (например, `$state()`), а пропсы — с помощью `$props()`. Реактивные объявления для побочных эффектов должны быть в блоках `$effect(() => { ... });`.

---

### **Ключевые архитектурные изменения**

В процессе разработки были внесены следующие ключевые архитектурные изменения для улучшения безопасности, модульности, производительности и пользовательского опыта:

1.  **Безопасное хранение API-ключей (Netlify Functions)**:
    *   API-ключ RAWG.io был перемещен с фронтенда в Netlify Function (`src/routes/api/search-game/+server.ts`).
    *   Переменная окружения в `.env` была переименована с `VITE_RAWG_API_KEY` на `RAWG_API_KEY` для обеспечения приватного доступа через `$env/static/private`.

2.  **Модульный дизайн компонентов**:
    *   **`GameSearch.svelte`**: Централизована логика поиска игр и пользовательский интерфейс в переиспользуемом компоненте.
    *   **`GameList.svelte`**: Централизована логика получения и отображения списков игр из Firebase, отфильтрованных по статусу.
    *   **`GameCard.svelte`**: Выделенный компонент для отображения информации об отдельных играх в списке, включая действия редактирования и удаления.
    *   **`GameEditModal.svelte`**: Выделенный компонент для редактирования деталей игры в модальной форме.

3.  **Оптимизированное взаимодействие с RAWG API**:
    *   **`src/routes/api/search-game/+server.ts`**: Теперь выполняет только первоначальный поиск (`/games` endpoint) и возвращает базовую информацию об играх (ID, название, год, обложка, жанры). Включена сортировка по рейтингу (`ordering=-rating`) и фильтрация по платформе PC (`platforms=4`).
    *   **`src/routes/api/game-details/+server.ts`**: Новый эндпоинт, который выполняет запрос к `/games/{id}` для получения детальной информации (разработчики, издатель, серия) только для выбранной игры.

4.  **Управление данными Firebase**:
    *   **Поле `rawg_id`**: Добавлено в документы Firebase для связывания игр с их ID из RAWG.io.
    *   **Поля `date_added` и `play_time`**: Добавлены в документы Firebase при добавлении игры.
    *   **Обработка `undefined` полей**: Реализована логика в `GameEditModal.svelte` для предотвращения записи `undefined` значений в Firebase путем их преобразования в пустые строки или массивы, или исключения из объекта обновления.
    *   **Удаление игр**: Реализована функциональность удаления игр через `GameCard` и `GameList` с подтверждением пользователя.

5.  **Клиентское кэширование и обратная связь в UI**:
    *   **`src/lib/stores/allGames.ts`**: Создан новый Svelte store для кэширования легковесного списка всех игр пользователя (Firestore ID, RAWG ID, название, статус) из Firebase. Подписка на изменения происходит один раз с помощью `onSnapshot`.
    *   **`GameSearch.svelte`**: Использует `allGames` store для:
        *   Проверки наличия игры из результатов поиска в библиотеке пользователя.
        *   Визуальной индикации уже добавленных игр (полупрозрачная маска, измененный курсор, текст "Added to [status]").
        *   Предотвращения повторного добавления существующих игр.

# Communication
Для общения с Gemini и программистом следует использовать русский язык.