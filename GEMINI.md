### Проект: "Pixel Journal"

#### **Цель проекта:**
Создание **многопользовательского** web-приложения для ведения персональных списков пройденных, запланированных и заброшенных игр. Это **serverless** проект.

#### **Технологический стек:**
-   **Backend:** Firebase (Firestore, Authentication), Cloudinary, Netlify Functions (для безопасных запросов).
-   **Hosting:** Netlify.
-   **Frontend:** HTML, CSS, Svelte, Flowbite Svelte.
-   **API:** RAWG.io для поиска информации об играх.

---

### **Архитектура источников данных (Data Source Architecture)**

Проект использует гибкую архитектуру, позволяющую подключать несколько внешних API для получения информации об играх (например, RAWG, IGDB) и давать пользователю возможность выбора между ними.

1.  **Принцип работы: "Настройка на клиенте, выполнение на сервере"**
    *   **Клиент:** Пользователь в настройках приложения выбирает желаемый источник данных (RAWG или IGDB) и вводит свои персональные API-ключи.
    *   **Сервер:** Когда фронтенд делает запрос (например, поиск игры), он обращается к собственным серверным эндпоинтам приложения (в `src/routes/api/*`). В этот запрос он безопасно передает API-ключ пользователя (через заголовок `Authorization`). Сами же вызовы к внешним API (RAWG, IGDB) происходят **только на сервере**. 

2.  **Паттерн "Провайдер"**
    *   Вся логика для работы с конкретным внешним API инкапсулирована в отдельном модуле — "провайдере". Все провайдеры лежат в `src/lib/data_sources` и реализуют общий интерфейс `IGameDataProvider`.
    *   Это позволяет легко добавлять новые источники данных, не затрагивая остальной код.

3.  **API-роуты как "Диспетчеры"**
    *   Серверные эндпоинты в `src/routes/api/*` больше не содержат логику обращения к конкретному API. Вместо этого они работают как "диспетчеры":
        1.  Принимают запрос от клиента.
        2.  Определяют, какой источник данных (`source`) и какой API-ключ (`Authorization`) использовать.
        3.  Вызывают соответствующий модуль-провайдер.
        4.  Возвращают клиенту результат в едином формате.

4.  **Хранение ключей**
    *   Персональные API-ключи каждого пользователя хранятся в его документе в коллекции `users` в Firestore. Управление ключами происходит на странице настроек.

**Вывод:** Такая архитектура обеспечивает высокую безопасность (ключи не "светятся" в браузере при запросах к внешним API), гибкость и масштабируемость.

---


### **ОСНОВНОЕ ОПИСАНИЕ**

1.  **Категории:** 
    - пользователь может сам создавать категории (каталоги) для сортироваки игр


2.  **Добавление игр:**
    -   Кнопка `ADD` на каждой странице.
    -   По нажатию появляется форма для поиска игры по названию.
    -   Игра добавляется в текущий список после поиска через **RAWG.io API**.

3.  **Отображение игр:**
    -   Каждая игра отображается в виде интерактивной карточки.
    -   На карточке должны быть поля: название, обложка, год выпуска, другая информация.

4.  **Пользовательские данные:**
    -   После добавления игры, пользователь может внести свою информацию, которая сохраняется в **Firebase**:
        -   Текстовая заметка.
        -   "Сердце" (отметка **My favorite game**).
        -   Рейтинг (от 1 до 5 звезд).

5.  **Перенос игр:**
    -   Функционал для переноса игры из одной категории в другую путем обновления поля `status` в документе Firestore.

---

### **Структура данных в Firebase Firestore**

Приложение является **многопользовательским**.

Есть корневая коллекция 'users'.

В нее помещены документы, соответствующие каждому пользоватлю, и с именем `userId`.

В каждом пользователе у нас есть коллекции `articles` и `games`. 

А так же два поля:
-   `tags` (array): Массив строк с пользовательскими тегами.
-   `categories` (array): Массив строк с пользовательскими категориями.


-   **Коллекция `games`**: Содержит игры всех пользователей.
    -   **Поля документа:**
        -   `userId` (string): **ОБЯЗАТЕЛЬНО.** ID пользователя из Firebase Authentication. Используется в правилах безопасности для разграничения доступа.
        -   `status` (string): Текущий статус игры (например, `Backlog`, `Completed`). Управляется пользователем.
        -   `title` (string): Название игры.
        -   `developer` (array): Массив строк с именами студий-разработчиков.
        -   `publisher` (string): Издатель.
        -   `year` (number): Год выпуска.
        -   `genres` (array): Массив жанров.
        -   `series` (string, optional): Серия, к которой относится игра.
        -   `image_url` (string): Ссылка на обложку с Cloudinary.
        -   `user_note` (string): Заметка пользователя.
        -   `is_favorite` (boolean): `true`, если игра отмечена как любимая.
        -   `user_rating` (number): Рейтинг от 1 до 5.
        -   `play_time` (number, optional): Время, потраченное на прохождение.
        -   `markdown_content` (string, optional): Содержимое для Markdown-заметок (для будущего).

---

### **Уже реализованные фичи**

-   **Теги:** Добавление пользовательских тегов (например, "хочу перепройти").
-   **Поиск:** Полнотекстовый поиск по играм (по названию, жанру, разработчику).
-   **Markdown-заметки:** Возможность создания подробных заметок с использованием Markdown-редактора.

---

### **Соглашения и особенности Svelte 5**

В проекте используется Svelte 5. Это вносит важные изменения в синтаксис обработки событий, которые нужно строго соблюдать.

#### **1. Устаревшая директива `on:` для DOM-событий**

Использование директивы `on:событие` (например, `on:click`, `on:submit`) для нативных DOM-элементов (`<button>`, `<a>`, `<form>`) **устарело**. Вместо этого следует использовать атрибуты событий в нижнем регистре.

*   **Правильно (Svelte 5):**
    ```svelte
    <form onsubmit={handleSubmit}>
        <button onclick={handleClick}>Нажми</button>
    </form>
    ```
*   **Неправильно (устарело):**
    ```svelte
    <!-- Этот код вызовет предупреждение при сборке -->
    <form on:submit={handleSubmit}>
        <button on:click={handleClick}>Нажми</button>
    </form>
    ```

#### **2. События компонентов и Callback Props**

Механизм `createEventDispatcher` из Svelte 4 **устарел**. Компоненты больше не "отправляют" события. Вместо этого они принимают функции обратного вызова (callback) как обычные `props`.

*   **Правильно (Svelte 5):**
    *   **Дочерний компонент (`Child.svelte`):**
        ```svelte
        <script>
          let { onMyEvent } = $props(); // Принимаем функцию как prop
        </script>
        <button onclick={() => onMyEvent('данные события')}>Вызвать</button>
        ```
    *   **Родительский компонент:**
        ```svelte
        <Child onmyevent={(data) => console.log(data)} />
        ```

*   **Неправильно (устарело):**
    *   **Дочерний компонент:**
        ```svelte
        // import { createEventDispatcher } from 'svelte';
        // const dispatch = createEventDispatcher();
        // dispatch('myEvent', 'данные события');
        ```
    *   **Родительский компонент:**
        ```svelte
        <Child on:myEvent={(event) => console.log(event.detail)} />
        ```

#### **3. Компоненты Flowbite-Svelte**

Библиотека `flowbite-svelte` адаптирована под Svelte 5 и также следует этим правилам. Для обработки событий на ее компонентах (например, `<Button>`, `<Modal>`) нужно использовать `props` в нижнем регистре (`onclick`, `onclose` и т.д.), а не директиву `on:`.

---

### **Ключевые архитектурные изменения**

В процессе разработки были внесены следующие ключевые архитектурные изменения для улучшения безопасности, модульности, производительности и пользовательского опыта:

1.  **Архитектура Провайдеров Данных (Data Provider Architecture)**:
    *   Реализован паттерн "Провайдер" для работы с внешними API. Логика для каждого источника данных (RAWG, IGDB) инкапсулирована в собственном модуле в `src/lib/data_sources`.
    *   Серверные роуты (`/api/*`) были преобразованы в "диспетчеры", которые вызывают нужный провайдер в зависимости от настроек пользователя.
    *   Внедрена система использования персональных API-ключей для каждого пользователя, которые хранятся в Firestore и передаются на сервер в заголовке `Authorization`.

2.  **Модульный дизайн компонентов**:
    *   **`GameSearch.svelte`**: Централизована логика поиска игр и пользовательский интерфейс в переиспользуемом компоненте.
    *   **`GameList.svelte`**: Централизована логика получения и отображения списков игр из Firebase, отфильтрованных по статусу.
    *   **`GameCard.svelte`**: Выделенный компонент для отображения информации об отдельных играх в списке, включая действия редактирования и удаления.
    *   **`GameEditModal.svelte`**: Выделенный компонент для редактирования деталей игры в модальной форме.

3.  **Оптимизированное взаимодействие с RAWG API**:
    *   **`src/routes/api/search-game/+server.ts`**: Теперь выполняет только первоначальный поиск (`/games` endpoint) и возвращает базовую информацию об играх (ID, название, год, обложка, жанры). Включена сортировка по рейтингу (`ordering=-rating`) и фильтрация по платформе PC (`platforms=4`).
    *   **`src/routes/api/game-details/+server.ts`**: Новый эндпоинт, который выполняет запрос к `/games/{id}` для получения детальной информации (разработчики, издатель, серия) только для выбранной игры.

4.  **Управление данными Firebase**:
    *   **Поле `rawg_id`**: Добавлено в документы Firebase для связывания игр с их ID из RAWG.io.
    *   **Поля `date_added` и `play_time`**: Добавлены в документы Firebase при добавлении игры.
    *   **Обработка `undefined` полей**: Реализована логика в `GameEditModal.svelte` для предотвращения записи `undefined` значений в Firebase путем их преобразования в пустые строки или массивы, или исключения из объекта обновления.
    *   **Удаление игр**: Реализована функциональность удаления игр через `GameCard` и `GameList` с подтверждением пользователя.

5.  **Клиентское кэширование и обратная связь в UI**:
    *   **`src/lib/stores/allGames.ts`**: Создан новый Svelte store для кэширования легковесного списка всех игр пользователя (Firestore ID, RAWG ID, название, статус) из Firebase. Подписка на изменения происходит один раз с помощью `onSnapshot`.
    *   **`GameSearch.svelte`**: Использует `allGames` store для:
        *   Проверки наличия игры из результатов поиска в библиотеке пользователя.
        *   Визуальной индикации уже добавленных игр (полупрозрачная маска, измененный курсор, текст "Added to [status]").
        *   Предотвращения повторного добавления существующих игр.

6.  **Единый компонент страницы (`GamePage.svelte`)**:
    *   Вся логика и разметка для страниц со списками игр (Backlog, Completed, Rejected, Abandoned) инкапсулирована в один переиспользуемый компонент `GamePage.svelte`.
    *   `GamePage.svelte` принимает пропс `status` (`'backlog' | 'completed' | 'rejected' | 'abandoned'`), что позволяет динамически отображать контент для каждой категории.
    -   Это значительно уменьшает дублирование кода и упрощает внесение изменений в функциональность страниц.

7.  **Оглавление (Table of Contents - TOC)**:
    *   Интегрирован компонент `GameTocSidebar.svelte` для отображения списка игр на текущей странице с возможностью быстрого перехода к ним.
    *   `GameList.svelte` передает список игр (`id` и `title`) в `GamePage.svelte` через пропс `onGamesUpdate`, который затем передает их в `GameTocSidebar.svelte`.
    *   Каждая `GameCard` теперь имеет уникальный `id="game-{game.id}"` для использования в качестве якоря.

### **Распространененные ошибки и их решения**

1.  **Ошибка `Cannot redeclare block-scoped variable $storeName` или `The $ prefix is reserved` в Svelte 5 Runes Mode**:
    *   **Проблема**: Попытка явно объявить реактивную переменную для Svelte store с использованием `$state()` (например, `let $user = $state(user);`) приводит к ошибке, так как Svelte 5 автоматически резервирует переменные с префиксом `$` для прямого доступа к значениям store.
    *   **Решение**: Не используйте `let $storeName = $state(storeName);` для подписки на существующие Svelte stores. Вместо этого, просто импортируйте store и используйте `$storeName` напрямую в разметке (`{#if $user}`) или в `$derived` выражениях (`let userEmail = $derived($user?.email);`). Префикс `$` автоматически обеспечивает реактивность и подписку на store.

2.  **Ошибка `ESLint: Use the $ prefix or the get function to access reactive values...` при работе с `$derived`**:
    *   **Проблема**: При создании производной переменной из стора (например, `let currentUser = $derived(user);`) возникает соблазн обращаться к ней в блоках `$effect` или других реактивных контекстах напрямую (`if (currentUser)`). Это вызывает ошибку линтера `svelte/require-store-reactive-access`.
    *   **Объяснение**: Переменная, созданная с помощью `$derived(store)`, сама является **производным стором (derived store)**, а не простым реактивным значением. Чтобы получить ее актуальное значение внутри `<script>`, необходимо использовать префикс `$`, как и для любого другого стора.
    *   **Решение**: Всегда используйте префикс `$` для доступа к значению переменной, созданной с помощью `$derived`.
        *   **Неправильно:**
            ```javascript
            let currentUser = $derived(user);
            $effect(() => {
              // ОШИБКА: currentUser здесь - это объект стора, а не его значение.
              if (currentUser && currentUser.uid) { 
                console.log(currentUser.uid);
              }
            });
            ```
        *   **Правильно:**
            ```javascript
            let currentUser = $derived(user);
            $effect(() => {
              // ПРАВИЛЬНО: $currentUser дает доступ к значению стора.
              if ($currentUser && $currentUser.uid) {
                console.log($currentUser.uid);
              }
            });
            ```

# Communication

- Для общения с Gemini и программистом следует использовать русский язык.

- **Online Документация для LLM**: Справка по компонентам, оптимизированная для LLM, доступна по адресу `https://flowbite-svelte.com/llm/components/*.md`, где `*` — это название компонента в нижнем регистре. Например, для компонента `Table` документация находится по адресу `https://flowbite-svelte.com/llm/components/table.md`.
- **Offline Документация для LLM**: В папке llm в проекте.
